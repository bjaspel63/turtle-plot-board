<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pyturtle.online Plot Board</title>
<style>
body { font-family: 'Inter', sans-serif; margin:0; display:flex; height:100vh; background:#f6f8fb; overflow:hidden; }
#leftPanel { flex:1; display:flex; justify-content:center; align-items:center; position:relative; min-width:300px; }
#rightPanel { width:250px; background:#fff; border-left:2px solid #ccc; display:flex; flex-direction:column; padding:12px; overflow-y:auto; }
#canvas { background:#fff; border:2px solid #ddd; box-shadow:0 0 8px rgba(0,0,0,0.1); cursor:grab; width:100%; height:100%; }
#canvas:active { cursor:grabbing; }
#controls { display:flex; flex-wrap:wrap; gap:6px; margin-bottom:8px; }
button,label { background:#0078d7; color:white; border:none; border-radius:6px; padding:6px 10px; cursor:pointer; font-size:14px; }
button:hover{background:#005fa3;}
input[type="checkbox"]{transform:scale(1.2); margin-left:6px; vertical-align:middle;}
#codeOutput { font-family:monospace; font-size:12px; background:#f0f0f0; padding:8px; border-radius:6px; margin-top:10px; white-space:pre-wrap; flex:1; }
.point-item { display:flex; justify-content:space-between; align-items:center; background:#f7f9fc; border:1px solid #e0e0e0; border-radius:6px; padding:4px 8px; margin-bottom:4px; cursor:pointer; }
.point-item.selected, .point-item.hover { background:#e0f0ff; }
.del-btn { background:none; color:red; border:none; font-size:16px; cursor:pointer; }
#fullscreenIcon { position:absolute; bottom:12px; right:12px; background:#0078d7; color:white; border:none; border-radius:50%; width:36px; height:36px; font-size:18px; cursor:pointer; }
#coordsDisplay { position:absolute; left:10px; bottom:10px; background:rgba(255,255,255,0.8); padding:4px 8px; border-radius:4px; font-family:monospace; font-size:12px; border:1px solid #ccc; pointer-events:none; }
</style>
</head>
<body>
<div id="leftPanel">
  <canvas id="canvas"></canvas>
  <button id="fullscreenIcon" title="Toggle Fullscreen">⛶</button>
  <div id="coordsDisplay">x:0, y:0</div>
</div>
<div id="rightPanel">
  <div id="controls">
    <button id="connectBtn">Connect Points</button>
    <button id="drawBtn">Draw Mode</button>
    <button id="undoBtn">Undo</button>
    <label><input type="checkbox" id="showNumbers" checked> Show Labels</label>
    <label><input type="checkbox" id="plotCircle"> Plot Circle</label>
    <button id="clearBtn">Clear</button>
    <button id="copyBtn">Copy Code</button>
    <button id="downloadBtn">Download</button>
    <button id="uploadBtn">Upload</button>
    <input type="file" id="uploadInput" accept=".json" style="display:none">
  </div>
  <h4>Plotted Points</h4>
  <div id="pointList"></div>
  <h4>Generated Turtle Code</h4>
  <pre id="codeOutput"></pre>
</div>

<script>
const canvas=document.getElementById('canvas');
const ctx=canvas.getContext('2d');
const pointList=document.getElementById('pointList');
const codeOutput=document.getElementById('codeOutput');
const connectBtn=document.getElementById('connectBtn');
const drawBtn=document.getElementById('drawBtn');
const undoBtn=document.getElementById('undoBtn');
const showNumbers=document.getElementById('showNumbers');
const clearBtn=document.getElementById('clearBtn');
const copyBtn=document.getElementById('copyBtn');
const fullscreenBtn=document.getElementById('fullscreenIcon');
const plotCircleCheckbox=document.getElementById('plotCircle');
const coordsDisplay=document.getElementById('coordsDisplay');
const downloadBtn=document.getElementById('downloadBtn');
const uploadBtn=document.getElementById('uploadBtn');
const uploadInput=document.getElementById('uploadInput');

let points=[];
let undonePoints=[];
let connectMode=false;
let drawMode=false;
let scale=1, offsetX=0, offsetY=0;
let originX=0, originY=0;
let isDragging=false,lastX=0,lastY=0;
let defaultCircleRadius=10;
let selectedPointIndex=null;
let hoverPointIndex=null;
let panMode=false;
let dragPointIndex=null;
let drawPath=[];

// Resize canvas
function resizeCanvas(){
  canvas.width=canvas.clientWidth;
  canvas.height=canvas.clientHeight;
  originX=canvas.width/2;
  originY=canvas.height/2;
  drawGrid();
}
window.addEventListener('resize',resizeCanvas);
resizeCanvas();

// Convert mouse event to canvas coordinates
function getCanvasCoords(e){
  const rect=canvas.getBoundingClientRect();
  const x=(e.clientX-rect.left-originX-offsetX)/scale;
  const y=-((e.clientY-rect.top-originY-offsetY)/scale);
  return {x, y};
}

// Draw everything
function drawGrid(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.translate(originX + offsetX, originY + offsetY);
  ctx.scale(scale, scale);

  // grid
  ctx.strokeStyle="#ddd";
  for(let i=-200;i<=200;i+=20){
    ctx.beginPath(); ctx.moveTo(-200,i); ctx.lineTo(200,i); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(i,-200); ctx.lineTo(i,200); ctx.stroke();
  }

  // axes
  ctx.strokeStyle="#333"; ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.moveTo(-200,0); ctx.lineTo(200,0); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0,-200); ctx.lineTo(0,200); ctx.stroke();

  // numbers
  ctx.fillStyle="#444"; ctx.font="10px Inter";
  for(let i=-200;i<=200;i+=50){ if(i!==0){ ctx.fillText(i,i+2,-2); ctx.fillText(i,2,-i-2); } }

  // connected line
  if(connectMode && points.length>1){
    ctx.strokeStyle="#0078d7"; ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(points[0].x,-points[0].y);
    for(let i=1;i<points.length;i++) ctx.lineTo(points[i].x,-points[i].y);
    ctx.stroke();
  }

  // draw points
  points.forEach((p,i)=>{
    ctx.beginPath();
    if(p.type==="circle") ctx.arc(p.x,-p.y,p.radius,0,Math.PI*2);
    else ctx.arc(p.x,-p.y,3,0,Math.PI*2);
    ctx.strokeStyle=(selectedPointIndex===i)?"#00b36b":(hoverPointIndex===i)?"#ffa500":"#0078d7";
    ctx.fillStyle=(p.type==="circle")?"transparent":"#0078d7";
    ctx.fill(); ctx.stroke();
    if(showNumbers.checked){
      ctx.fillStyle="#000";
      ctx.fillText(i+1,p.x + (p.type==="circle"?p.radius+4:5), -p.y - (p.type==="circle"?p.radius+4:5));
    }
  });

  ctx.restore();
  updateCode();
}

// Mouse events
canvas.addEventListener('mousedown',(e)=>{
  const {x,y}=getCanvasCoords(e);
  panMode=e.shiftKey;
  dragPointIndex=null;

  if(drawMode){
    drawPath=[];
    points.push({x:Math.round(x), y:Math.round(y), type:"dot", radius:defaultCircleRadius});
    drawPath.push(points.length-1);
  } else if(!panMode){
    points.forEach((p,i)=>{
      const dist=Math.sqrt((x-p.x)**2 + (y-p.y)**2);
      if((p.type==="circle" && dist<=p.radius+5) || (p.type==="dot" && dist<=5)){
        dragPointIndex=i; selectedPointIndex=i;
      }
    });

    if(dragPointIndex===null){
      points.push({x:Math.round(x), y:Math.round(y), type:plotCircleCheckbox.checked?"circle":"dot", radius:defaultCircleRadius});
      selectedPointIndex=points.length-1;
    }
  }

  isDragging=true; lastX=e.clientX; lastY=e.clientY;
  updatePointList(); drawGrid();
});

canvas.addEventListener('mousemove',(e)=>{
  const {x,y}=getCanvasCoords(e);
  coordsDisplay.textContent=`x:${Math.round(x)}, y:${Math.round(y)}`;

  hoverPointIndex=null;
  points.forEach((p,i)=>{
    const dist=Math.sqrt((x-p.x)**2 + (y-p.y)**2);
    if(p.type==="circle" && dist<=p.radius+5) hoverPointIndex=i;
    if(p.type==="dot" && dist<=5) hoverPointIndex=i;
  });

  if(isDragging){
    if(drawMode){
      points.push({x:Math.round(x), y:Math.round(y), type:"dot", radius:defaultCircleRadius});
      drawPath.push(points.length-1);
    } else if(dragPointIndex!==null){
      points[dragPointIndex].x += (e.clientX-lastX)/scale;
      points[dragPointIndex].y -= (e.clientY-lastY)/scale;
      points[dragPointIndex].x=Math.round(points[dragPointIndex].x);
      points[dragPointIndex].y=Math.round(points[dragPointIndex].y);
      updatePointList();
    } else if(panMode){
      offsetX += e.clientX - lastX;
      offsetY += e.clientY - lastY;
    }
    lastX = e.clientX;
    lastY = e.clientY;
    drawGrid();
  } else drawGrid();
});

canvas.addEventListener('mouseup',()=>{ isDragging=false; dragPointIndex=null; panMode=false; });
canvas.addEventListener('mouseleave',()=>{ isDragging=false; dragPointIndex=null; panMode=false; });

// Zoom
canvas.addEventListener('wheel',(e)=>{
  e.preventDefault();
  const delta=Math.sign(e.deltaY);
  if(delta<0 && scale<2) scale*=1.1;
  if(delta>0 && scale>0.5) scale/=1.1;
  drawGrid();
},{passive:false});

// Undo / Redo
function undo(){
  if(points.length>0){
    undonePoints.push(points.pop());
    updatePointList(); drawGrid();
  }
}
function redo(){
  if(undonePoints.length>0){
    points.push(undonePoints.pop());
    updatePointList(); drawGrid();
  }
}
undoBtn.onclick=undo;
document.addEventListener('keydown',(e)=>{
  if(e.key.toLowerCase()==='z') undo();
  if(e.key.toLowerCase()==='y') redo();
});

// Download / Upload
downloadBtn.onclick=()=>{
  const dataStr="data:text/json;charset=utf-8,"+encodeURIComponent(JSON.stringify(points,null,2));
  const a=document.createElement('a');
  a.href=dataStr; a.download="points.json";
  a.click();
};
uploadBtn.onclick=()=>uploadInput.click();
uploadInput.onchange=(e)=>{
  const file=e.target.files[0];
  if(!file)return;
  const reader=new FileReader();
  reader.onload=(evt)=>{
    try{
      points=JSON.parse(evt.target.result);
      updatePointList(); drawGrid();
    }catch(err){alert("Invalid JSON file.");}
  };
  reader.readAsText(file);
};

// Update point list
function updatePointList(){
  pointList.innerHTML="";
  points.forEach((p,i)=>{
    const div=document.createElement('div');
    div.className="point-item";
    if(selectedPointIndex===i) div.classList.add('selected');
    if(hoverPointIndex===i && selectedPointIndex!==i) div.classList.add('hover');
    div.innerHTML=`${i+1}. (${p.x}, ${p.y})${p.type==="circle"?` - Circle r=${p.radius}`:""} <button class="del-btn" data-i="${i}">🗑️</button>`;
    div.onclick=()=>{ selectedPointIndex=i; updatePointList(); drawGrid(); };
    pointList.appendChild(div);
  });
  document.querySelectorAll('.del-btn').forEach(btn=>{
    btn.onclick=(e)=>{
      e.stopPropagation();
      points.splice(btn.dataset.i,1);
      updatePointList(); drawGrid();
    };
  });
}

// Buttons
connectBtn.onclick=()=>{ connectMode=!connectMode; connectBtn.style.background=connectMode?"#00b36b":"#0078d7"; drawGrid(); };
drawBtn.onclick=()=>{ drawMode=!drawMode; drawBtn.style.background=drawMode?"#00b36b":"#0078d7"; };
clearBtn.onclick=()=>{ points=[]; undonePoints=[]; updatePointList(); selectedPointIndex=null; hoverPointIndex=null; offsetX=0; offsetY=0; scale=1; resizeCanvas(); };
copyBtn.onclick=()=>{ navigator.clipboard.writeText(codeOutput.textContent).then(()=>alert("Code copied!")); };

// Circle radius
document.addEventListener('keydown',(e)=>{
  if(selectedPointIndex===null) return;
  let p=points[selectedPointIndex];
  if(p.type!=="circle") return;
  if(e.key.toLowerCase()==='c'){ p.radius+=2; drawGrid(); updatePointList(); }
  if(e.key.toLowerCase()==='v'){ p.radius=Math.max(2,p.radius-2); drawGrid(); updatePointList(); }
});

showNumbers.onchange=drawGrid;
plotCircleCheckbox.onchange=drawGrid;

// Fullscreen
fullscreenBtn.onclick=()=>{ if(!document.fullscreenElement) canvas.requestFullscreen(); else document.exitFullscreen(); };
document.addEventListener('fullscreenchange',()=>{ if(!document.fullscreenElement){ scale=1; offsetX=0; offsetY=0; resizeCanvas(); } else drawGrid(); });

// Generate Turtle code
function updateCode(){
  let code=`import turtle as t\n`;
  code+=`t.penup()\n`;
  points.forEach((p,i)=>{
    if(i===0) code+=`t.goto(${p.x}, ${p.y})\nt.pendown()\n`;
    else code+=`t.goto(${p.x}, ${p.y})\n`;
    if(p.type==="circle"){
      code+=`t.penup()\nt.goto(${p.x}, ${p.y - p.radius})\nt.pendown()\nt.circle(${p.radius})\nt.penup()\nt.goto(${p.x}, ${p.y})\n`;
    }
  });
  if(connectMode && points.length>1) code+=`t.goto(${points[0].x}, ${points[0].y})\n`;
  code+=`t.done()`;
  codeOutput.textContent=code;
}
</script>
</body>
</html>
